#!/usr/bin/env python3.3
# -*- coding: utf-8 -*-
#
# Database layer
#  translates database calls to functions
#
# Software is free software released under the "Modified BSD license"
#

# Copyright (c) 2014-2015       Pieter-Jan Moreels - pieterjan.moreels@gmail.com

# imports
from lib.Config import Configuration as conf
import pymongo
import re

# Variables
db=conf.getMongoConnection()
colCVE=      db['cves']
colCPE=      db['cpe']
colCPEOTHER= db['cpeother']
colWHITELIST=db['mgmt_whitelist']
colBLACKLIST=db['mgmt_blacklist']
colUSERS=    db['mgmt_users']
colSEEN=     db['mgmt_seen']
colINFO=     db['info']
colVFEED=    db['vfeed']
# Functions
def sanitize(x):
  if type(x)==pymongo.cursor.Cursor:
    x=list(x)
  if type(x)==list:
    for y in x: sanitize(y)
  if x and  "_id" in x: x.pop("_id")
  return x

# DB Functions
def ensureIndex(col, field):
  db[col].ensure_index(field)

def setColUpdate(collection, date):
  colINFO.update({"db": collection}, {"$set": {"last-modified": date}}, upsert=True)

def insertCVE(cve):
  colCVE.insert(cve)

def updateCVE(cve):
  colCVE.update({"id": cve['id']}, {"$set": {"cvss": cve['cvss'], "summary": cve['summary'], "references": cve['references'],
                                             "cwe": cve['cwe'], "vulnerable_configuration": cve['vulnerable_configuration'],
                                             "vulnerable_configuration_cpe_2_2": cve['vulnerable_configuration_cpe_2_2'], 'last-modified': cve['Modified']}})

# API Functions
def cvesForCPE(cpe):
  if not cpe: return []
  return sanitize(colCVE.find({"vulnerable_configuration": {"$regex": cpe}}).sort("Modified", -1))

# User Functions
def seenCVEs(user):
  data = colSEEN.find_one({"user": user})
  if not data:
    colSEEN.insert({"user": user, "seen_cves": []})
    return []
  else:
    return data['seen_cves']

def addSeenCVEs(user, CVEs):
  if type(CVEs) == str: CVEs=[CVEs]
  if type(CVEs) == list:
    seen=list(set(CVEs)-set(seenCVEs(user)))
    if seen:
      colSEEN.update({"user": user},{"$addToSet": {"seen_cves": { "$each": seen}}})

def removeSeenCVEs(user, CVEs):
  if type(CVEs) == str: CVEs=[CVEs]
  if type(CVEs) == list:
    colSEEN.update({"user": user}, {"$pullAll": {"seen_cves": CVEs}})

def isMasterAccount(user):
  return False if colUSERS.find({"username": user, "master": True}).count() == 0 else True

def userExists(user):
  return True if colUSERS.find({"username": user}).count() > 0 else False

def isSingleMaster(user):
  return True if len(list(colUSERS.find({"username": {"$ne": user}, "master": True}))) == 0 else False

# Query Functions
# Generic data
def getCVEs(limit=-1, query=[], skip=0):
  if type(query) == dict: query=[query]
  if len(query) == 0:
    cves=colCVE.find().sort("Modified", -1).limit(limit).skip(skip)
  elif len(query)  == 1:
    cves=colCVE.find(query[0]).sort("Modified", -1).limit(limit).skip(skip)
  else:
    cves=colCVE.find({"$and": query}).sort("Modified", -1).limit(limit).skip(skip)
  return sanitize(cves)

def getCVEIDs(limit=-1):
  return [x["id"] for x in colCVE.find().limit(limit).sort("Modified", -1)]

def getCVE(id):
  return sanitize(colCVE.find_one({"id": id}))

def getCPE(id):
  return sanitize(colCPE.find_one({"id": id}))

def getCPEMatching(regex, fullSearch=False):
  lst=list(colCPE.find({"id": {"$regex": regex}}))
  if fullSearch: lst.extend(colCPEOTHER.find({"id": {"$regex": regex}}))
  return lst

def getAlternativeCPE(id):
  return sanitize(colCPEOTHER.find_one({"id": id}))

def getFreeText(text):
  return [x["obj"] for x in db.command("text", "cves", search=text)["results"]]

def getInfo(collection):
  return sanitize(colINFO.find_one({"db": collection}))

def getLastModified(collection):
  info=getInfo(collection)
  return info['last-modified'] if info else None

def getSize(collection):
  return db[collection].count()

def vFeedLinked(key, val):
  print(key)
  print(val)
  cveList=[x['id'] for x in colVFEED.find({key: val})]
  return sanitize(getCVEs(query={'id':{'$in':cveList}}))

def getDBStats():
  cols=['cve', 'cpe', 'cpeOther', 'capec', 'd2sec', 'vendor', 'vfeed']
  stats={x+'A': getSize(x.lower()) for x in cols}
  stats['cveA']=getSize('cves')
  stats.update({x+'U': getLastModified(x.lower()) for x in cols})
  stats.update({'blA': colBLACKLIST.count(), 'wlA':colWHITELIST.count()})
  stats.update({'dbOnDisk': db.command("dbstats")['storageSize'], 'dbSize':db.command('dbstats')['dataSize']})
  stats['dbName']=conf.getMongoDB()
  return stats

# Dynamic data
def getWhitelist():
  return sanitize(colWHITELIST.find())

def getRules(list):
  if list.lower()=='whitelist':
    col=colWHITELIST
  elif list.lower()=='blacklist':
    col=colBLACKLIST
  else:
    return []
  rlist=col.find({'type':'cpe'}).distinct('id')
  hardware=["cpe:2.3:([^:]*:){9}"+re.escape(x) for x in col.find({'type':'targethardware'}).distinct('id')]
  software=["cpe:2.3:([^:]*:){8}"+re.escape(x) for x in col.find({'type':'targetsoftware'}).distinct('id')]
  rlist.extend(hardware)
  rlist.extend(software)
  return rlist


def getBlacklist():
  return sanitize(colBLACKLIST.find())

# Users
def getUsers():
  return sanitize(colUSERS.find())

def getUser(user):
  return sanitize(colUSERS.find_one({"username": user}))
