#!/usr/bin/env python3.3
# -*- coding: utf-8 -*-
#
# Simple web interface to cve-search to display the last entries
# and view a specific CVE.
#
# Software is free software released under the "Modified BSD license"
#

# Copyright (c) 2013-2015 	Alexandre Dulaunoy - a@foo.be
# Copyright (c) 2014-2015 	Pieter-Jan Moreels - pieterjan.moreels@gmail.com

# imports
import os
import sys
_runPath = os.path.dirname(os.path.realpath(__file__))
sys.path.append(os.path.join(_runPath, ".."))

from tornado.wsgi import WSGIContainer
from tornado.httpserver import HTTPServer
from tornado.ioloop import IOLoop
from flask import Flask, render_template, request, jsonify
from flask.ext.pymongo import PyMongo
from redis import exceptions as redisExceptions

import json
import re
import argparse
import time
import urllib
import random
import signal
import logging
from logging.handlers import RotatingFileHandler

from lib.Config import Configuration
from lib.Toolkit import toStringFormattedCPE, toOldCPE, currentTime, isURL, vFeedName, convertDateToDBFormat
import lib.CVEs as cves

# parse command line arguments
argparser = argparse.ArgumentParser(description='Start CVE-Search web component')
argparser.add_argument('-v', action='store_true', help='verbose output')
args = argparser.parse_args()

# variables
app = Flask(__name__, static_folder='static', static_url_path='/static')
app.config['MONGO_DBNAME'] = Configuration.getMongoDB()
app.config['SECRET_KEY'] = str(random.getrandbits(256))
pageLength = Configuration.getPageLength()

# db connectors
db = Configuration.getMongoConnection()
redisdb = Configuration.getRedisVendorConnection()

# functions
def getBrowseList(vendor):
    result = {}
    if (vendor is None) or type(vendor) == list:
        v1 = redisdb.smembers("t:/o")
        v2 = redisdb.smembers("t:/a")
        v3 = redisdb.smembers("t:/h")
        vendor = sorted(list(set(list(v1) + list(v2) + list(v3))))
        cpe = None
    else:
        cpenum = redisdb.scard("v:" + vendor)
        if cpenum < 1:
            return page_not_found(404)
        p = redisdb.smembers("v:" + vendor)
        cpe = sorted(list(p))
    result["vendor"] = vendor
    result["product"] = cpe
    return result


def getVersionsOfProduct(product):
    p = redisdb.smembers("p:" + product)
    return sorted(list(p))


    cveU = db.info.find_one({'db': 'cve'})
    cpeU = db.info.find_one({'db': 'cpe'})
    cpeOtherU = db.info.find_one({'db': 'cpeother'})
    capecU = db.info.find_one({'db': 'capec'})
    d2secU = db.info.find_one({'db': 'd2sec'})
    vendorU = db.info.find_one({'db': 'vendor'})
    vfeedU = db.info.find_one({'db': 'vfeed'})
    stats = {'cveA': db.cves.count(), 'cveU': cveU['last-modified'] if cveU is not None else None,
             'cpeA': db.cpe.count(), 'cpeU': cpeU['last-modified'] if cpeU is not None else None,
             'cpeOtherA': db.cpeother.count(), 'cpeOtherU': cpeOtherU['last-modified'] if cpeOtherU is not None else None,
             'capecA': db.capec.count(), 'capecU': capecU['last-modified'] if capecU is not None else None,
             'd2secA': db.d2sec.count(), 'd2secU': d2secU['last-modified'] if d2secU is not None else None,
             'vendorA': db.vendor.count(), 'vendorU': vendorU['last-modified'] if vendorU is not None else None,
             'vfeedA': db.vfeed.count(), 'vfeedU': vfeedU['last-modified'] if vfeedU is not None else None,
             'blA': db.mgmt_blacklist.count(), 'wlA': db.mgmt_whitelist.count(),
             'dbName': Configuration.getMongoDB(), 'dbSize': db.command("dbstats")['dataSize'],
             'dbOnDisk': db.command("dbstats")['storageSize']}
    return stats


def filter_logic(unlisted, timeSelect, startDate, endDate,
                 timeTypeSelect, cvssSelect, cvss, rejectedSelect, limit, skip):
    collection = db.cves
    query = []
    # retrieving lists
    if rejectedSelect == "hide":
        exp = "^(?!\*\* REJECT \*\*\s+DO NOT USE THIS CANDIDATE NUMBER.*)"
        query.append({'summary': re.compile(exp)})
    # cvss logic
    if cvssSelect != "all":
        if cvssSelect == "above":
            query.append({'cvss': {'$gt': float(cvss)}})
        if cvssSelect == "equals":
            query.append({'cvss': float(cvss)})
        if cvssSelect == "below":
            query.append({'cvss': {'$lt': float(cvss)}})
    # date logic
    if timeSelect != "all":
        startDate = convertDateToDBFormat(startDate)
        endDate = convertDateToDBFormat(endDate)
        if timeSelect == "from":
            query.append({timeTypeSelect: {'$gt': startDate}})
        if timeSelect == "until":
            query.append({timeTypeSelect: {'$lt': endDate}})
        if timeSelect == "between":
            query.append({timeTypeSelect: {'$gt': startDate, '$lt': endDate}})
        if timeSelect == "outside":
            query.append({'$or': [{timeTypeSelect: {'$lt': startDate}}, {timeTypeSelect: {'$gt': endDate}}]})
    if len(query) == 0:
        cve = collection.find().sort("Modified", -1).limit(limit).skip(skip)
    elif len(query) == 1:
        cve = collection.find(query[0]).sort("Modified", -1).limit(limit).skip(skip)
    else:
        cve = collection.find({'$and': query}).sort("Modified", -1).limit(limit).skip(skip)
    # marking relevant records
    cve = list(cve)
    return cve

# routes
@app.route('/')
def index():
    # get default page on HTTP get (navigating to page)
    unlisted = "show"
    timeSelect = "all"
    startDate = None
    endDate = None
    timeTypeSelect = "Modified"
    cvssSelect = "all"
    cvss = None
    rejectedSelect = "hide"
    cve = filter_logic(unlisted, timeSelect, startDate, endDate,
                       timeTypeSelect, cvssSelect, cvss, rejectedSelect, pageLength, 0)
    return render_template('index-minimal.html', cve=cve, r=0, pageLength=pageLength)

@app.route('/', methods=['POST'])
def filterPost():
    unlisted = request.form.get('unlistedSelect')
    timeSelect = request.form.get('timeSelect')
    startDate = request.form.get('startDate')
    endDate = request.form.get('endDate')
    timeTypeSelect = request.form.get('timeTypeSelect')
    cvssSelect = request.form.get('cvssSelect')
    cvss = request.form.get('cvss')
    rejectedSelect = request.form.get('rejectedSelect')
    settings = {'unlistedSelect': unlisted, 'timeSelect': timeSelect,
                'startDate': startDate, 'endDate': endDate,
                'timeTypeSelect': timeTypeSelect, 'cvssSelect': cvssSelect,
                'cvss': cvss, 'rejectedSelect': rejectedSelect}
    # retrieving data
    cve = filter_logic(unlisted, timeSelect, startDate, endDate,
                       timeTypeSelect, cvssSelect, cvss, rejectedSelect, pageLength, 0)
    return render_template('index-minimal.html', settings=settings, cve=cve, r=0, pageLength=pageLength)


@app.route('/r/<int:r>', methods=['POST', 'GET'])
def filterLast(r):
    if not r:
        r = 0
    blacklist = request.form.get('blacklistSelect')
    whitelist = request.form.get('whitelistSelect')
    unlisted = request.form.get('unlistedSelect')
    timeSelect = request.form.get('timeSelect')
    startDate = request.form.get('startDate')
    endDate = request.form.get('endDate')
    timeTypeSelect = request.form.get('timeTypeSelect')
    cvssSelect = request.form.get('cvssSelect')
    cvss = request.form.get('cvss')
    rejectedSelect = request.form.get('rejectedSelect')
    settings = {'blacklistSelect': blacklist, 'whitelistSelect': whitelist,
                'unlistedSelect': unlisted, 'timeSelect': timeSelect,
                'startDate': startDate, 'endDate': endDate,
                'timeTypeSelect': timeTypeSelect, 'cvssSelect': cvssSelect,
                'cvss': cvss, 'rejectedSelect': rejectedSelect}
    # retrieving data
    cve = filter_logic(unlisted, timeSelect, startDate, endDate,
                       timeTypeSelect, cvssSelect, cvss, rejectedSelect, pageLength, r)
    return render_template('index-minimal.html', settings=settings, cve=cve, r=r, pageLength=pageLength)

@app.route('/api/cpe2.3/<path:cpe>', methods=['GET'])
def cpe23(cpe):
    cpe = toStringFormattedCPE(cpe)
    if not cpe: cpe='None'
    return cpe

@app.route('/api/cpe2.2/<path:cpe>', methods=['GET'])
def cpe22(cpe):
    cpe = toOldCPE(cpe)
    if not cpe: cpe='None'
    return cpe

@app.route('/api/cvefor/<path:cpe>', methods=['GET'])
def apiCVEFor(cpe):
    col = db['cves']
    cpe=urllib.parse.unquote_plus(cpe)
    cpe=toStringFormattedCPE(cpe)
    if not cpe: cpe='None'
    vulns = col.find({"vulnerable_configuration": {'$regex': cpe}}).sort("Modified", -1)
    r = []
    cvesp = cves.last(rankinglookup=False, namelookup=False, vfeedlookup=True, capeclookup=False)
    for x in vulns:
        r.append(cvesp.getcve(x['id']))
    return json.dumps(r)

@app.route('/api/cve/<cveid>', methods=['GET'])
def apiCVE(cveid):
    cvesp = cves.last(rankinglookup=True, namelookup=True, vfeedlookup=True, capeclookup=True)
    cve = cvesp.getcve(cveid=cveid)
    if cve is None:
        cve = {}
    return (jsonify(cve))

@app.route('/api/browse/<vendor>', methods=['GET'])
@app.route('/api/browse/', methods=['GET'])
@app.route('/api/browse', methods=['GET'])
def apibrowse(vendor=None):
    if vendor is not None:
        vendor = urllib.parse.quote_plus(vendor).lower()
    browseList = getBrowseList(vendor)
    if isinstance(browseList, dict):
        return (jsonify(browseList))
    else:
        return (jsonify({}))

@app.route('/api/last/', methods=['GET'])
@app.route('/api/last', methods=['GET'])
def apilast():
    limit = 30
    cvesp = cves.last(rankinglookup=True, namelookup=True, vfeedlookup=True, capeclookup=True)
    cve = cvesp.get(limit=limit)
    return (jsonify({"results": cve} ))

@app.route('/api/search/<vendor>/<path:product>', methods=['GET'])
def apisearch(vendor=None, product=None):
    if vendor is None or product is None:
        return (jsonify({}))
    collection = db.cves
    search = vendor + ":" + product
    cves = collection.find({"vulnerable_configuration": {'$regex': search}}).sort("Modified", -1)
    r = []
    for cve in cves:
        cve.pop('_id')
        r.append(cve)
    return (json.dumps(r))

@app.route('/cve/<cveid>')
def cve(cveid):
    cveid = cveid.upper()
    cvesp = cves.last(rankinglookup=True, namelookup=True, vfeedlookup=True, capeclookup=True,subscorelookup=True)
    cve = cvesp.getcve(cveid=cveid)
    if cve is None:
        return render_template('error.html',status={'except':'cve-not-found','info':{'cve':cveid}},minimal=True)
    return render_template('cve.html', cve=cve, minimal=True)


@app.route('/browse/<vendor>')
@app.route('/browse/')
def browse(vendor=None):
    try:
        if vendor is not None:
            vendor = urllib.parse.quote_plus(vendor).lower()
        browseList = getBrowseList(vendor)
        vendor = browseList["vendor"]
        product = browseList["product"]
        return render_template('browse.html', product=product, vendor=vendor, minimal=True)
    except redisExceptions.ConnectionError:
        return render_template('error.html',
                               status={'except':'redis-connection',
                                       'info':{'host':Configuration.getRedisHost(),'port':Configuration.getRedisPort()}})


@app.route('/search', methods=['POST'])
def searchText():
    search = request.form.get('search')
    collection = db.cves
    try:
        cvelist = db.command("text", "cves", search=search)["results"]
    except:
        return render_template('error.html', status={'except':'textsearch-not-enabled'})
    cve=[x["obj"] for x in cvelist]
    return render_template('search.html', cve=cve, minimal=True)


@app.route('/search/<vendor>/<path:product>')
def search(vendor=None, product=None):
    collection = db.cves
    search = vendor + ":" + product
    cve = collection.find({"vulnerable_configuration": {'$regex': search}}).sort("Modified", -1)
    return render_template('search.html', vendor=vendor, product=product, cve=cve, minimal=True)

@app.route('/link/<vFeedMap>/<field>/<path:value>')
def link(vFeedMap=None,field=None,value=None):
    vFeedMap=htmlDedode(vFeedMap)
    field=htmlDedode(field)
    value=htmlDedode(value)
    search="%s.%s"%(vFeedMap,field)
    regex = re.compile(re.escape(value), re.I)
    cveList=[x['id'] for x in db.vfeed.find({search: regex}).sort("Modified",-1)]
    cve = list(db.cves.find({'id':{'$in': cveList}}).sort("Modified",-1))
    cvssList=[float(x['cvss']) for x in cve if 'cvss' in x]
    stats={'maxCVSS': max(cvssList), 'minCVSS': min(cvssList),'count':len(cve)}
    return render_template('linked.html', vFeedMap=vFeedMap, field=field, value=value, cve=cve, stats=stats, minimal=True)

# error handeling
@app.errorhandler(404)
def page_not_found(e):
    return render_template('404.html', minimal=True), 404


# filters
@app.template_filter('currentTime')
def currentTimeFilter(utc):
    return currentTime(utc)


@app.template_filter('htmlDecode')
def htmlDedode(string):
    return urllib.parse.unquote_plus(string)


@app.template_filter('htmlEncode')
def htmlEncode(string):
    return urllib.parse.quote_plus(string).lower()


@app.template_filter('isURL')
def isURLFilter(string):
    return isURL(string)

@app.template_filter('vFeedName')
def vFeedNameFilter(string):
    return vFeedName(string)

# signal handlers
def sig_handler(sig, frame):
    print('Caught signal: %s' % sig)
    IOLoop.instance().add_callback(shutdown)


def shutdown():
    MAX_WAIT_SECONDS_BEFORE_SHUTDOWN = 3
    print('Stopping http server')
    http_server.stop()

    print('Will shutdown in %s seconds ...' % MAX_WAIT_SECONDS_BEFORE_SHUTDOWN)
    io_loop = IOLoop.instance()
    deadline = time.time() + MAX_WAIT_SECONDS_BEFORE_SHUTDOWN

    def stop_loop():
        now = time.time()
        if now < deadline and (io_loop._callbacks or io_loop._timeouts):
            io_loop.add_timeout(now + 1, stop_loop)
        else:
            io_loop.stop()
            print('Shutdown')
    stop_loop()

if __name__ == '__main__':
    # get properties
    flaskHost = Configuration.getFlaskHost()
    flaskPort = Configuration.getFlaskPort()
    flaskDebug = Configuration.getFlaskDebug()
    # logging
    if Configuration.getLogging():
        logfile = Configuration.getLogfile()
        pathToLog = logfile.rsplit('/', 1)[0]
        if not os.path.exists(pathToLog):
            os.makedirs(pathToLog)
        maxLogSize = Configuration.getMaxLogSize()
        backlog = Configuration.getBacklog()
        file_handler = RotatingFileHandler(logfile, maxBytes=maxLogSize, backupCount=backlog)
        file_handler.setLevel(logging.ERROR)
        formatter = logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s")
        file_handler.setFormatter(formatter)
        app.logger.addHandler(file_handler)

    if flaskDebug:
        # start debug flask server
        app.run(host=flaskHost, port=flaskPort, debug=flaskDebug)
    else:
        # start asynchronous server using tornado wrapper for flask
        # ssl connection
        print("Server starting...")
        if Configuration.useSSL():
            cert = os.path.join(_runPath, "../", Configuration.getSSLCert())
            key = os.path.join(_runPath, "../", Configuration.getSSLKey())
            ssl_options = {"certfile": cert,
                           "keyfile": key}
        else:
            ssl_options = None
        signal.signal(signal.SIGTERM, sig_handler)
        signal.signal(signal.SIGINT, sig_handler)
        global http_server
        http_server = HTTPServer(WSGIContainer(app), ssl_options=ssl_options)
        http_server.bind(flaskPort, address=flaskHost)
        http_server.start(0)  # Forks multiple sub-processes
        IOLoop.instance().start()
